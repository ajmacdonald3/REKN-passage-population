---
title: "Supporting Information"
editor_options:
  chunk_output_type: console
date: "5 October 2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy.opts=list(width.cutoff=60), tidy=TRUE)
```

MacDonald, A. J., P. A. Smith, C. A. Friis, J. E. Lyons, Y. Aubry, and E. Nol. 2020. Stopover Ecology of Red Knots in Southwestern James Bay During Southbound Migration. Journal of Wildlife Management.

## JAGS code for integrated population models

All JAGS and R code for the analyses in this paper is available at <https://github.com/ajmacdonald3/REKN-passage-population>.

JAGS code adapted from Lyons et al. (2016), Lyons et al. (2018), and Kéry and Schaub (2012).

### Constant persistence and time-dependent resighting model ($\beta_t \phi_c p_t \pi_t A_t$)

```{r, eval = FALSE}

model {
  # Priors and constraints
  for (i in 1:M) {
    for (t in 1:(n.occasions - 1)) {
      phi[i, t] <- mean.phi
      } #t
    for (t in 1:n.occasions) {
      p[i, t] <- psight[t]
      } #t
    } #i
  
  # Persistence
  
  mean.phi ~ dunif(0, 1)
  
  # Resight
  
  for (t in 1:n.occasions) {
    psight[t] ~ dunif(0, 1)
    }
  
  # Prior for inclusion probability
  
  psi ~ dunif(0, 1)
  
  # Dirichlet prior for entry probabilities
  for (t in 1:n.occasions) {
    beta[t] ~ dgamma(1, 1)
    b[t] <- beta[t] / sum(beta[1:n.occasions])
  }
  
  # Convert entry probs to conditional entry probs
  nu[1] <- b[1]
  for (t in 2:n.occasions) {
    nu[t] <- b[t] / (1 - sum(b[1:(t - 1)]))
  } #t
  
  # Likelihood
  for (i in 1:M) {
    # First occasion
    # State process
    w[i] ~ dbern(psi)                  # Draw latent inclusion
    z[i, 1] ~ dbern(nu[1])
    # Observation process
    mu1[i] <- z[i, 1] * p[i, 1] * w[i]
    y[i, 1] ~ dbern(mu1[i])
  
    # Subsequent occasions
    for (t in 2:n.occasions) {
      # State process
      q[i, t - 1] <- 1 - z[i, t - 1]
      mu2[i, t] <- phi[i, t - 1] * z[i, t - 1] + nu[t] * prod(q[i, 1:(t - 1)])
      z[i, t] ~ dbern(mu2[i, t])
      # Observation process
      mu3[i, t] <- z[i, t] * p[i, t] * w[i]
      y[i, t] ~ dbern(mu3[i, t])
      } #t
    } #i
  
  # ------------- flag scans ---------------------------------
  
  # GLMM for scan samples
  
  # Priors
  
  alpha ~ dnorm(0, 0.001)
  
  for (i in 1:n.per) {
    delta[i] ~ dnorm(0, tau.per)
  }
  
  tau.per <- pow(sigma.per,-2)
  
  sigma.per ~ dunif(0, 10)
  
  # Likelihood
  
  for (i in 1:n) {
    m[i] ~ dbin(lp[i], K[i])
  
    logit(lp[i]) <- alpha + delta[per[i]]
  }
  
  for (i in 1:n.per) {
    pflag[i] <- exp(alpha + delta[i])/(1 + exp(alpha + delta[i]))
  }
  
  meanpflag <- exp(alpha)/(1 + exp(alpha))
  
  # ------------- end : flag scans ---------------------------------
  
  # -------------------- age scans ---------------------------------
  # GLM for age scans
  
  # Priors
  
  for (i in 1:n.per) {
    beta.rper[i] ~ dnorm(0, 0.001)
  }
  
  # Likelihood
  
  for (i in 1:n2) {
    a[i] ~ dbin(pad[i], Tot[i]) # Distribution for random part
    logit(pad[i]) <- beta.rper[rper[i]] # Link function and linear predictor
  }
  
  for (j in 1:n.per) {
    padult[j] <- 1/(1 + exp(-beta.rper[j])) # convert logit to prob/proportion
  }
  
  meanpadult <- mean(padult[])
  
  # ------------- end : age scans ---------------------------------
  
  # Calculate derived population parameters
  for (i in 1:M) {
    for (t in 1:n.occasions) {
      u[i, t] <- z[i, t] * w[i]     # Deflated latent state (u)
    }
  }
  
  for (i in 1:M) {
    recruit[i, 1] <- u[i, 1]
    for (t in 2:n.occasions) {
      recruit[i, t] <- (1 - u[i, t - 1]) * u[i, t]
    } #t
  } #i
  
  for (t in 1:n.occasions) {
    Nflag[t] <- sum(u[1:M, t])                         # Number of flagged birds
    Nstopadult[t] <- sum(u[1:M, t])/pflag[t]
    Nstop_t[t] <- sum((u[1:M, t])/pflag[t])/padult[t]
    Bflag[t] <- sum(recruit[1:M, t])                   # Number of flagged entries
    Bstopadult[t] <- sum(recruit[1:M, t])/pflag[t]
    Bstop_t[t] <- (sum((recruit[1:M, t]))/pflag[t])/padult[t]
  } #t
  
  for (i in 1:M) {
    Nind[i] <- sum(u[i, 1:n.occasions])
    Nalive[i] <- 1 - equals(Nind[i], 0)
  } #i
  
  Nsuperflag <- sum(Nalive[])         # Superpopulation size
  Nsuperstopadult <- sum(Bstopadult[])
  Nsuperstop_Bt <- sum(Bstop_t[])
  
  # ------------------- Stopover duration -----------------------------------
  
  for (i in 1:n.ch) {
    zstop[i] <- sum(u[i, 1:n.occasions]) * 3
  }
  
  zes.days <- mean(zstop[])
  
  # ------------------- end : Stopover duration -----------------------------
  
}

```

### Time-dependent persistence and constant resighting model ($\beta_t \phi_t p_c \pi_t A_t$)

```{r, eval = FALSE}

model {
  # Priors and constraints
  for (i in 1:M) {
    for (t in 1:(n.occasions - 1)) {
      phi[i, t] <- phi_t[t]
    } # t
  for (t in 1:n.occasions) {
    p[i, t] <- mean.p
    }
  }
  
  # Persistence
  
  for (t in 1:(n.occasions - 1)) {
    phi_t[t] ~ dunif(0, 1)
  }
  
  # Resight
  
  mean.p ~ dunif(0, 1)
  
  for (t in 1:n.occasions) {
    gamma[t] ~ dunif(0, 1)
  }
  
  # Likelihood
  for (i in 1:M) {
    # First occasion
    # State process
    z[i, 1] ~ dbern(gamma[1])
    mu1[i] <- z[i, 1] * p[i, 1]
  
    # Observation process
    y[i, 1] ~ dbern(mu1[i])
  
    # Subsequent occasions
    for (t in 2:n.occasions) {
      # State process
      q[i, t - 1] <- 1 - z[i, t - 1] # Availability for recruitment
      mu2[i, t] <-
      phi[i, t - 1] * z[i, t - 1] + gamma[t] * prod(q[i, 1:(t - 1)])
      z[i, t] ~ dbern(mu2[i, t])
  
    # Observation process
    mu3[i, t] <- z[i, t] * p[i, t]
    y[i, t] ~ dbern(mu3[i, t])
    } # t
  } # i
  
  # ------------- flag scans ---------------------------------
  
  # GLMM for scan samples
  
  # Priors
  
  alpha ~ dnorm(0, 0.001)
  
  for (i in 1:n.per) {
    delta[i] ~ dnorm(0, tau.per)
  }
  
  tau.per <- pow(sigma.per,-2)
  
  sigma.per ~ dunif(0, 10)
  
  # Likelihood
  
  for (i in 1:n) {
    m[i] ~ dbin(lp[i], K[i])
  
    logit(lp[i]) <- alpha + delta[per[i]]
  }
  
  for (i in 1:n.per) {
    pflag[i] <- exp(alpha + delta[i])/(1 + exp(alpha + delta[i]))
  }
  
  meanpflag <- exp(alpha)/(1 + exp(alpha))
  
  # ------------- end : flag scans ---------------------------------
  
  # ------------- age scans ---------------------------------
  
  # GLM for age scans
  
  # Priors
  
  for (i in 1:n.per) {
    beta.rper[i] ~ dnorm(0, 0.001)
  }
  
  # Likelihood
  
  for (i in 1:n2) {
    a[i] ~ dbin(pad[i], Tot[i]) # Distribution for random part
    logit(pad[i]) <- beta.rper[rper[i]] # Link function and linear predictor
  }
  
  for (j in 1:n.per) {
    padult[j] <- 1/(1 + exp(-beta.rper[j])) # convert logit to prob/proportion
  }
  
  meanpadult <- mean(padult[])
  
  # ------------- end : age scans ---------------------------------
  
  # Calculate derived population parameters
  for (t in 1:n.occasions) {
    qgamma [t] <- 1 - gamma[t]
  }
  
  cprob[1] <- gamma[1]
  for (t in 2:n.occasions) {
    cprob[t] <- gamma[t] * prod(qgamma[1:(t - 1)])
  } # t
  
  psi <- sum(cprob[])                                 # Inclusion probability
  
  for (t in 1:n.occasions) {
    b[t] <- cprob[t]/psi                              # Entry probability
  } # t
  
  for (i in 1:M) {
    recruit[i, 1] <- z[i, 1]
    for (t in 2:n.occasions) {
      recruit[i, t] <- (1 - z[i, t - 1]) * z[i, t]
    }
  }
  
  for (t in 1:n.occasions) {
    Nflag[t] <- sum(z[1:M, t])
    Nstopadult[t] <- sum(z[1:M, t])/pflag[t]
    Nstop_t[t] <- sum((z[1:M, t])/pflag[t])/padult[t]
    Bflag[t] <- sum(recruit[1:M, t])
    Bstopadult[t] <- sum(recruit[1:M, t])/pflag[t]
    Bstop_t[t] <- (sum((recruit[1:M, t]))/pflag[t])/padult[t]
  }
  
  for (i in 1:M) {
    Nind[i] <- sum(z[i, 1:n.occasions])
    Nalive[i] <- 1 - equals(Nind[i], 0)
  }
  
  Nsuperflag <- sum(Nalive[])
  Nsuperstopadult <- sum(Bstopadult[])
  Nsuperstop_Bt <- sum(Bstop_t[])
  
  # ------------------- Stopover duration -----------------------------------
  
  for (i in 1:n.ch) {
    zstop[i] <- sum(z[i, 1:n.occasions]) * 3
  }
  
  zes.days <- mean(zstop[])
  
  # ------------------- end : Stopover duration ------------------------------
  
}

```

**Literature Cited**

Kéry, M., and M. Schaub. 2012. Bayesian population analysis using WinBUGS: a hierarchical perspective. Academic Press, Waltham, Massachusetts, USA.

Lyons, J. E., W. L. Kendall, J. A. Royle, S. J. Converse, B. A. Andres, and J. B. Buchanan. 2016. Population size and stopover duration estimation using mark-resight data and Bayesian analysis of a superpopulation model. Biometrics 72:262–271. 

Lyons, J. E., B. Winn, T. Keyes, and K. S. Kalasz. 2018. Post-breeding migration and connectivity of Red Knots in the Western Atlantic. Journal of Wildlife Management 82:383–396.
